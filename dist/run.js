"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/raceRecording.ts
var raceRecording_exports = {};
__export(raceRecording_exports, {
  default: () => raceRecording_default
});
var raceRecording_default;
var init_raceRecording = __esm({
  "src/raceRecording.ts"() {
    "use strict";
    raceRecording_default = [
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 0
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 532.6999999880791
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 698.1999999880791
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 1282.800000011921
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 1433.199999988079
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 1538
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 1920.300000011921
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 2078.0999999940395
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 2310.0999999940395
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 2693.0999999940395
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 2865.199999988079
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 3382.9000000059605
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 3503.199999988079
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 3539.9000000059605
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 3818.199999988079
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 3998.0999999940395
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 4538.199999988079
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 4590.300000011921
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 4725.0999999940395
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 4748
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 4898.300000011921
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 5715
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 5933.199999988079
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 6075.199999988079
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 6308.300000011921
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 6488.199999988079
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 7628.4000000059605
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 7988.199999988079
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 9780.40000000596
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 10043.40000000596
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 10433.300000011921
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 11250
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 11679.09999999404
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 11685
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 12180.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 12293.300000011921
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 12525.40000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 12885.5
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 13320.5
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 13688.5
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 14213.09999999404
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 14273.199999988079
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 14610.5
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 15278.300000011921
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 15743.5
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 16470.19999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 16905.5
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 17348.59999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 17641.09999999404
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 17948.69999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 17970.30000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 18188.59999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 18488.59999999404
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 19065.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 19395.59999999404
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 19688.59999999404
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 19733.40000000596
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 19958.69999998808
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 20243.69999998808
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 20625.59999999404
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 21458.80000001192
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 21600.69999998808
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 21960.59999999404
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 22178.5
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 22569
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 22590.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 22658.40000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 22793.59999999404
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 22800.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 23301
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 23565.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 23700.80000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 24023.59999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 24690.80000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 25178.69999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 25568.69999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 26220.40000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 26708.80000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 27098.80000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 27548.90000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 28028.80000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 28509
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 29153.5
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 29708.90000000596
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 29813.69999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 29910.80000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 29933.59999999404
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 30324.09999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 30750.80000001192
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 31021
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 31253.80000001192
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 31801.30000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 32003.90000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 32356.19999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 32581.09999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 32768.90000000596
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 33841
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 33991
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 34185.90000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 35281
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 35895.69999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 36609.09999999404
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 37298.80000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 37801.19999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 38370.80000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 39466.09999999404
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 39804.19999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 40074.30000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 40486.09999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 40816.30000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 41124.09999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 41694.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 42054.19999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 42286.5
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 42564.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 42721.30000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 42916.09999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 43186.30000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 43733.90000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 44101.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 44341.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 44431.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 44589.19999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 44709.19999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 45324
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 45946.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 46396.5
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 46749.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 47161.40000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 47716.30000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 47904.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 48099.90000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 48264.40000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 48429.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 48564.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 48721.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 48901.40000000596
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 49104.59999999404
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 49306.30000001192
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 50199.5
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 50304.30000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 50394.30000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 50431.19999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 50776.59999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 50814.30000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 51099.5
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 51106.09999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 51294.40000000596
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 51301.19999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 52336.30000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 52344.19999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 52651.59999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 52846.40000000596
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 52944.59999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 53176.5
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 53476.5
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 53776.5
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 54031.5
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 54286.40000000596
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 54571.69999998808
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 55014.59999999404
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 55171.5
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 55726.30000001192
      },
      {
        type: "keydown",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 56041.59999999404
      },
      {
        type: "keyup",
        key: "ArrowLeft",
        code: "ArrowLeft",
        time: 56356.59999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 56499.40000000596
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 56971.59999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 57136.5
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 57399.5
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 57759.69999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 57909.59999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 58044.80000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 58089.40000000596
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 58321.69999998808
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 58839.30000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 58914.59999999404
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 58936.59999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 59116.59999999404
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 59409.80000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 59791.59999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 60204.69999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 60594.69999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 60976.80000001192
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 60984.30000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 61389.59999999404
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 61621.80000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 62311.40000000596
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 62476.80000001192
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 62566.69999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 62897.69999998808
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 62964.59999999404
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 63174.69999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 63669.69999998808
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 63887.69999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 63954.69999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 64082.80000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 64307.69999998808
      },
      {
        type: "keydown",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 64412.69999998808
      },
      {
        type: "keyup",
        key: "ArrowUp",
        code: "ArrowUp",
        time: 64899.80000001192
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 64997.90000000596
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 65222.69999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 65507.90000000596
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 65642.69999998808
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 65874.80000001192
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 66009.80000001192
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 66212.90000000596
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 66317.80000001192
      },
      {
        type: "keydown",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 66903.09999999404
      },
      {
        type: "keyup",
        key: "ArrowRight",
        code: "ArrowRight",
        time: 67029.80000001192
      }
    ];
  }
});

// bin/run.ts
var import_yargs = __toESM(require("yargs"));
var import_dotenv = require("dotenv");

// src/commands/batch.ts
var batch_exports = {};
__export(batch_exports, {
  aliases: () => aliases,
  builder: () => builder,
  command: () => command,
  describe: () => describe,
  handler: () => handler
});
var import_node_child_process = require("child_process");
var import_node_fs = __toESM(require("fs"));
var import_node_path = __toESM(require("path"));

// src/logger.ts
var import_consola = require("consola");
var logger = (0, import_consola.createConsola)({});

// src/commands/batch.ts
var command = "batch";
var describe = "Run multiple analysis configurations sequentially";
var aliases = ["b"];
function builder(yargs2) {
  return yargs2.option("configFile", {
    type: "string",
    alias: "c",
    description: "Path to JSON config file with configuration options",
    default: "batch-config-combinations.json"
  }).option("delay", {
    type: "number",
    alias: "d",
    description: "Delay in seconds between consecutive runs",
    default: 3
  }).option("maxRetries", {
    type: "number",
    alias: "r",
    description: "Maximum number of retries for failed tests",
    default: 20
  }).option("startIndex", {
    type: "number",
    alias: "s",
    description: "Index of the configuration to start from (0-based)",
    default: 0
  }).option("runsPerConfig", {
    type: "number",
    alias: "n",
    description: "Number of times to execute each configuration",
    default: 1
  });
}
function generateConfigurations(options) {
  let configurations = [{}];
  if (options.clients && options.clients.length > 0) {
    const newConfigs = [];
    for (const config2 of configurations) {
      for (const client of options.clients) {
        newConfigs.push({ ...config2, clients: client });
      }
    }
    configurations = newConfigs;
  }
  if (options.duration && options.duration.length > 0) {
    const newConfigs = [];
    for (const config2 of configurations) {
      for (const duration2 of options.duration) {
        newConfigs.push({ ...config2, duration: duration2 });
      }
    }
    configurations = newConfigs;
  }
  if (options.resolutions && options.resolutions.length > 0) {
    const newConfigs = [];
    for (const config2 of configurations) {
      for (const resolution of options.resolutions) {
        newConfigs.push({
          ...config2,
          width: resolution.width,
          height: resolution.height
        });
      }
    }
    configurations = newConfigs;
  }
  if (options.frameRate && options.frameRate.length > 0) {
    const newConfigs = [];
    for (const config2 of configurations) {
      for (const frameRate of options.frameRate) {
        newConfigs.push({ ...config2, frameRate });
      }
    }
    configurations = newConfigs;
  }
  if (options.audio && options.audio.length > 0) {
    const newConfigs = [];
    for (const config2 of configurations) {
      for (const audio of options.audio) {
        newConfigs.push({ ...config2, audio });
      }
    }
    configurations = newConfigs;
  }
  if (options.hardware && options.hardware.length > 0) {
    const newConfigs = [];
    for (const config2 of configurations) {
      for (const hardware of options.hardware) {
        newConfigs.push({ ...config2, hardware });
      }
    }
    configurations = newConfigs;
  }
  if (options.runsPerConfig && options.runsPerConfig.length > 0) {
    const newConfigs = [];
    for (const config2 of configurations) {
      for (const runsPerConfig of options.runsPerConfig) {
        newConfigs.push({ ...config2, runsPerConfig });
      }
    }
    configurations = newConfigs;
  }
  if (options.filter) {
    try {
      const filterFn = new Function("config", `return ${options.filter};`);
      configurations = configurations.filter((config2) => filterFn(config2));
    } catch (error) {
      logger.error(`Error applying filter: ${error}`);
    }
  }
  return configurations;
}
async function handler(argv) {
  const configFile = argv.configFile;
  const delaySeconds = argv.delay;
  const maxRetries = argv.maxRetries;
  const startIndex = argv.startIndex;
  const commandLineRunsPerConfig = argv.runsPerConfig;
  logger.info(`Starting batch run using config file: ${configFile}`);
  try {
    const configPath = import_node_path.default.resolve(process.cwd(), configFile);
    const configContent = import_node_fs.default.readFileSync(configPath, "utf8");
    const configOptions = JSON.parse(configContent);
    let configurations;
    if (Array.isArray(configOptions)) {
      logger.info(
        "Using legacy configuration format (array of explicit configurations)"
      );
      configurations = configOptions;
    } else {
      logger.info("Generating configurations from options");
      configurations = generateConfigurations(configOptions);
      logger.info(
        `Generated ${configurations.length} configurations from options`
      );
    }
    if (configurations.length === 0) {
      logger.error("No valid configurations found or generated");
      return;
    }
    logger.info(`Found ${configurations.length} configurations to run`);
    if (startIndex < 0 || startIndex >= configurations.length) {
      logger.error(
        `Invalid startIndex: ${startIndex}. Must be between 0 and ${configurations.length - 1}`
      );
      return;
    }
    if (startIndex > 0) {
      logger.info(
        `Starting from configuration index ${startIndex} (skipping ${startIndex} configurations)`
      );
    }
    for (let i = startIndex; i < configurations.length; i++) {
      const config2 = configurations[i];
      if (!config2 || typeof config2 !== "object") {
        logger.error(`Invalid configuration found at index ${i}, skipping`);
        continue;
      }
      logger.info(
        `Running configuration ${i}/${configurations.length - 1} --clients ${config2.clients} --duration ${config2.duration} --width ${config2.width} --height ${config2.height} --frameRate ${config2.frameRate} --audio ${config2.audio} --hardware ${config2.hardware}`
      );
      const runsPerConfig = config2.runsPerConfig || commandLineRunsPerConfig || 1;
      for (let runNumber = 1; runNumber <= runsPerConfig; runNumber++) {
        if (runsPerConfig > 1) {
          logger.info(
            `Run ${runNumber}/${runsPerConfig} for configuration ${i}`
          );
        }
        const command3 = `tsx ./bin/run.ts start --clients ${config2.clients} --duration ${config2.duration} --width ${config2.width} --height ${config2.height} --frameRate ${config2.frameRate} --audio ${config2.audio} --hardware ${config2.hardware}`;
        let success = false;
        let retryCount = 0;
        while (!success && retryCount <= maxRetries) {
          if (retryCount > 0) {
            logger.info(
              `Retry attempt ${retryCount} of ${maxRetries} for configuration ${i}: --clients ${config2.clients} --duration ${config2.duration} --width ${config2.width} --height ${config2.height}`
            );
            logger.info(`Waiting ${delaySeconds} seconds before retrying...`);
            await new Promise(
              (resolve) => setTimeout(resolve, delaySeconds * 1e3)
            );
          }
          logger.info(`Executing: ${command3}`);
          try {
            (0, import_node_child_process.execSync)(command3, {
              stdio: "inherit",
              windowsHide: true
            });
            logger.info(`Configuration ${i} completed successfully`);
            success = true;
          } catch (error) {
            const err = error;
            if (err.status) {
              logger.error(`Test failed with exit code: ${err.status}`);
            } else {
              logger.error("Error running configuration:", error);
            }
            retryCount++;
            if (retryCount > maxRetries) {
              logger.error(
                `Maximum retry attempts (${maxRetries}) reached for configuration ${i}. Exiting...`
              );
              logger.info(
                `To resume testing, run: tsx ./bin/run.ts batch --startIndex ${i + 1}`
              );
              process.exit(1);
            }
          }
        }
        if (i < configurations.length - 1 || runNumber < runsPerConfig) {
          logger.info(
            `Waiting ${delaySeconds} seconds before starting next configuration...`
          );
          await new Promise(
            (resolve) => setTimeout(resolve, delaySeconds * 1e3)
          );
        }
      }
    }
    logger.info("Batch run completed successfully");
  } catch (error) {
    logger.error("Error running batch command:", error);
  }
}

// src/commands/start.ts
var start_exports = {};
__export(start_exports, {
  aliases: () => aliases2,
  builder: () => builder2,
  command: () => command2,
  describe: () => describe2,
  handler: () => handler2
});

// src/clientCommander.ts
var import_node_events = require("events");
var import_puppeteer_core = __toESM(require("puppeteer-core"));

// src/webrtcDumpParser.ts
var WebrtcDumpParser = class {
  data;
  constructor(fileContents) {
    this.data = JSON.parse(fileContents);
  }
  parseStats(key, stats, timeSeriesMap) {
    const [_, statName] = key.split("-");
    const statNameSanitized = statName.replace(/\[/g, "").replace(/\]/g, "").replace(/\//g, "_per_");
    if (statNameSanitized === "estimatedPlayoutTimestamp") {
      return;
    }
    const values = JSON.parse(stats[key].values);
    values.forEach((value, index) => {
      const entry = timeSeriesMap[index];
      if (entry) {
        entry[statNameSanitized] = value;
      }
    });
  }
  parseTimes(key, stats, timeSeriesMap) {
    const values = JSON.parse(stats[key].values);
    values.forEach((value, index) => {
      timeSeriesMap.push({
        timestamp: new Date(value)
      });
    });
  }
  parse() {
    const connectionKey = Object.keys(this.data.PeerConnections)[0];
    const stats = this.data.PeerConnections[connectionKey].stats;
    const dataTimeSeriesMap = new Array();
    const audioTimeSeriesMap = new Array();
    const videoTimeSeriesMap = new Array();
    const candidatePairTimeSeriesMap = new Array();
    for (const key of Object.keys(stats)) {
      if (key.endsWith("-timestamp")) {
        if (key.startsWith("IT01V")) {
          this.parseTimes(key, stats, videoTimeSeriesMap);
        } else if (key.startsWith("IT01A")) {
          this.parseTimes(key, stats, audioTimeSeriesMap);
        } else if (key.startsWith("D1")) {
          this.parseTimes(key, stats, dataTimeSeriesMap);
        } else if (key.startsWith("CP")) {
          this.parseTimes(key, stats, candidatePairTimeSeriesMap);
        }
      }
    }
    for (const key of Object.keys(stats)) {
      if (!key.endsWith("-timestamp")) {
        if (key.startsWith("IT01V")) {
          this.parseStats(key, stats, videoTimeSeriesMap);
        } else if (key.startsWith("IT01A")) {
          this.parseStats(key, stats, audioTimeSeriesMap);
        } else if (key.startsWith("D1")) {
          this.parseStats(key, stats, dataTimeSeriesMap);
        } else if (key.startsWith("CP")) {
          this.parseStats(key, stats, candidatePairTimeSeriesMap);
        }
      }
    }
    return {
      dataChannelMetrics: dataTimeSeriesMap,
      audioMetrics: audioTimeSeriesMap,
      videoMetrics: videoTimeSeriesMap,
      candidatePairMetrics: candidatePairTimeSeriesMap
    };
  }
};

// src/clientCommander.ts
var ClientCommander = class extends import_node_events.EventEmitter {
  browser;
  gamePage;
  webrtcPage;
  url;
  constructor(url) {
    super();
    this.url = url;
  }
  async wait(seconds) {
    await new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
  }
  async start() {
    const params = new URLSearchParams({
      key: "epmginrvteyodpawwnvdorveupwudcprwsdslx",
      user: "demo",
      browserName: "chrome",
      region: "aws-us-east-1"
    }).toString();
    this.browser = await import_puppeteer_core.default.connect({
      browserWSEndpoint: `wss://cdp.testable.io?${params.toString()}`
    });
    logger.info("Connected to BrowserStack.");
    this.webrtcPage = await this.browser.newPage();
    await this.webrtcPage.goto("chrome://webrtc-internals");
    this.gamePage = await this.browser.newPage();
    await this.gamePage.exposeFunction("gameReady", async () => {
      await this.gamePage.evaluate(() => {
        const button = document.querySelector(
          ".fullscreen-button"
        );
        if (button) {
          button.click();
        }
      });
      await this.wait(1);
      this.emit("gameReady");
    });
    await this.gamePage.goto(this.url);
  }
  async startGame() {
    await this.wait(4);
    await this.replayRace();
  }
  async replayRace() {
    const raceRecording = (await Promise.resolve().then(() => (init_raceRecording(), raceRecording_exports))).default;
    const startTime = Date.now();
    try {
      const client = await this.gamePage.createCDPSession();
      for (const event of raceRecording) {
        const timeToWait = event.time - (Date.now() - startTime);
        if (timeToWait > 0) {
          await new Promise((resolve) => setTimeout(resolve, timeToWait));
        }
        if (event.type === "keydown") {
          await client.send("Input.dispatchKeyEvent", {
            autoRepeat: false,
            code: event.code,
            isKeypad: false,
            isSystemKey: true,
            key: event.key,
            text: void 0,
            type: "keyDown",
            keyIdentifier: event.code,
            nativeVirtualKeyCode: void 0,
            windowsVirtualKeyCode: void 0
          });
        } else if (event.type === "keyup") {
          await client.send("Input.dispatchKeyEvent", {
            autoRepeat: false,
            code: event.code,
            isKeypad: false,
            isSystemKey: true,
            key: event.key,
            text: void 0,
            type: "keyUp",
            keyIdentifier: event.code,
            nativeVirtualKeyCode: void 0,
            windowsVirtualKeyCode: void 0
          });
        }
      }
    } catch (e) {
      return;
    }
  }
  async stop() {
    logger.info("Stopping client...");
    if (this.browser) {
      logger.info("Closing browser...");
      await this.webrtcPage.evaluate(() => {
        const originalCreateObjectURL = URL.createObjectURL;
        URL.createObjectURL = (blob) => {
          window._webrtcDumpBlob = blob;
          return originalCreateObjectURL(blob);
        };
      });
      await this.webrtcPage.evaluate(() => {
        const button = document.querySelector("button");
        button.click();
      });
      await this.wait(1);
      const webrtcDumpContent = await this.webrtcPage.evaluate(async () => {
        const blob = window._webrtcDumpBlob;
        if (!blob) {
          return null;
        }
        return await blob.text();
      });
      const parser = new WebrtcDumpParser(webrtcDumpContent);
      const results = parser.parse();
      this.emit("metrics", results);
      const delayValues = await this.gamePage.evaluate(() => {
        return window.getDelayValues();
      });
      this.emit("delayValues", delayValues);
      await this.browser.close();
    }
  }
};

// src/databaseManager.ts
var import_pg = require("pg");
var DatabaseManager = class {
  pool;
  constructor(connectionConfig) {
    this.pool = new import_pg.Pool(connectionConfig);
  }
  async initialize() {
    try {
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS runs (
          id SERIAL PRIMARY KEY,
          clients BIGINT NOT NULL,
          width BIGINT NOT NULL,
          height BIGINT NOT NULL,
          duration BIGINT NOT NULL,
          audio BOOLEAN NOT NULL,
          frame_rate BIGINT NOT NULL,
          hardware BOOLEAN NOT NULL,
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          game_started_at TIMESTAMP WITH TIME ZONE NOT NULL
        )
      `);
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS performance_metrics (
          id SERIAL PRIMARY KEY,
          run_id BIGINT NOT NULL REFERENCES runs(id),
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          gpu_utilization REAL NOT NULL,
          working_set_private REAL NOT NULL,
          cpu_usage REAL NOT NULL,
          bytes_received REAL NOT NULL,
          bytes_sent REAL NOT NULL,
          packets_received REAL NOT NULL,
          packets_sent REAL NOT NULL,
          nv_gpu_power REAL,
          nv_gpu_temp REAL,
          nv_gpu_mem_temp REAL,
          nv_gpu_sm REAL,
          nv_gpu_mem REAL,
          nv_gpu_enc REAL,
          nv_gpu_dec REAL,
          nv_gpu_jpg REAL,
          nv_gpu_ofa REAL,
          nv_gpu_mem_clock REAL,
          nv_gpu_clock REAL
        )
      `);
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS webrtc_data_metrics (
          id SERIAL PRIMARY KEY,
          run_id BIGINT NOT NULL REFERENCES runs(id),
          client_id BIGINT NOT NULL,
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          label TEXT,
          protocol TEXT,
          data_channel_identifier BIGINT,
          state TEXT,
          messages_sent BIGINT,
          messages_sent_per_s REAL,
          bytes_sent BIGINT,
          bytes_sent_in_bits_per_s REAL,
          messages_received BIGINT,
          messages_received_per_s REAL,
          bytes_received BIGINT,
          bytes_received_in_bits_per_s REAL
        )
      `);
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS webrtc_audio_metrics (
          id SERIAL PRIMARY KEY,
          run_id BIGINT NOT NULL REFERENCES runs(id),
          client_id BIGINT NOT NULL,
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          ssrc BIGINT,
          kind TEXT,
          transport_id TEXT,
          codec_id TEXT,
          codec TEXT,
          jitter REAL,
          packets_lost BIGINT,
          playout_id TEXT,
          track_identifier TEXT,
          mid BIGINT,
          remote_id TEXT,
          packets_received BIGINT,
          packets_received_per_s REAL,
          packets_discarded BIGINT,
          packets_discarded_per_s REAL,
          fec_packets_received BIGINT,
          fec_packets_received_per_s REAL,
          fec_packets_discarded BIGINT,
          fec_packets_discarded_per_s REAL,
          bytes_received BIGINT,
          bytes_received_in_bits_per_s REAL,
          header_bytes_received BIGINT,
          header_bytes_received_in_bits_per_s REAL,
          last_packet_received_timestamp TEXT,
          jitter_buffer_delay REAL,
          jitter_buffer_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          jitter_buffer_target_delay REAL,
          jitter_buffer_target_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          jitter_buffer_minimum_delay REAL,
          jitter_buffer_minimum_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          jitter_buffer_emitted_count BIGINT,
          total_samples_received BIGINT,
          total_samples_received_per_s REAL,
          concealed_samples BIGINT,
          concealed_samples_per_s REAL,
          concealed_samples_per_total_samples_received REAL,
          silent_concealed_samples BIGINT,
          silent_concealed_samples_per_s REAL,
          concealment_events BIGINT,
          inserted_samples_for_deceleration BIGINT,
          inserted_samples_for_deceleration_per_s REAL,
          removed_samples_for_acceleration BIGINT,
          removed_samples_for_acceleration_per_s REAL,
          audio_level REAL,
          total_audio_energy REAL,
          audio_level_in_rms REAL,
          total_samples_duration REAL,
          total_processing_delay REAL,
          total_processing_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          jitter_buffer_flushes BIGINT,
          delayed_packet_outage_samples BIGINT,
          relative_packet_arrival_delay REAL,
          interruption_count BIGINT,
          total_interruption_duration REAL
        )
      `);
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS webrtc_video_metrics (
          id SERIAL PRIMARY KEY,
          run_id BIGINT NOT NULL REFERENCES runs(id),
          client_id BIGINT NOT NULL,
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          ssrc BIGINT,
          kind TEXT,
          transport_id TEXT,
          codec_id TEXT,
          codec TEXT,
          jitter REAL,
          packets_lost BIGINT,
          track_identifier TEXT,
          mid BIGINT,
          packets_received BIGINT,
          packets_received_per_s REAL,
          bytes_received BIGINT,
          bytes_received_in_bits_per_s REAL,
          header_bytes_received BIGINT,
          header_bytes_received_in_bits_per_s REAL,
          retransmitted_packets_received BIGINT,
          retransmitted_packets_received_per_s REAL,
          retransmitted_bytes_received BIGINT,
          retransmitted_bytes_received_in_bits_per_s REAL,
          rtx_ssrc BIGINT,
          last_packet_received_timestamp TEXT,
          jitter_buffer_delay REAL,
          jitter_buffer_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          jitter_buffer_target_delay REAL,
          jitter_buffer_target_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          jitter_buffer_minimum_delay REAL,
          jitter_buffer_minimum_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          jitter_buffer_emitted_count BIGINT,
          frames_received BIGINT,
          frames_received_per_s REAL,
          frame_width BIGINT,
          frame_height BIGINT,
          frames_per_second BIGINT,
          frames_decoded BIGINT,
          frames_decoded_per_s REAL,
          key_frames_decoded BIGINT,
          key_frames_decoded_per_s REAL,
          frames_dropped BIGINT,
          total_decode_time REAL,
          total_decode_time_per_frames_decoded_in_ms REAL,
          total_processing_delay REAL,
          total_processing_delay_per_jitter_buffer_emitted_count_in_ms REAL,
          total_assembly_time REAL,
          total_assembly_time_per_frames_assembled_from_multiple_packets_in_ms REAL,
          frames_assembled_from_multiple_packets BIGINT,
          total_inter_frame_delay REAL,
          total_inter_frame_delay_per_frames_decoded_in_ms REAL,
          total_squared_inter_frame_delay REAL,
          inter_frame_delay_st_dev_in_ms REAL,
          pause_count BIGINT,
          total_pauses_duration REAL,
          freeze_count BIGINT,
          total_freezes_duration REAL,
          decoder_implementation TEXT,
          fir_count BIGINT,
          pli_count BIGINT,
          nack_count BIGINT,
          goog_timing_frame_info TEXT,
          power_efficient_decoder BOOLEAN,
          min_playout_delay REAL
        )
      `);
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS webrtc_candidate_pair_metrics (
          id SERIAL PRIMARY KEY,
          run_id BIGINT NOT NULL REFERENCES runs(id),
          client_id BIGINT NOT NULL,
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          transport_id TEXT,
          local_candidate_id TEXT,
          remote_candidate_id TEXT,
          state TEXT,
          priority BIGINT,
          nominated BOOLEAN,
          writable BOOLEAN,
          packets_sent BIGINT,
          packets_sent_per_s REAL,
          bytes_sent BIGINT,
          bytes_sent_in_bits_per_s REAL,
          packets_received BIGINT,
          packets_received_per_s REAL,
          bytes_received BIGINT,
          bytes_received_in_bits_per_s REAL,
          total_round_trip_time REAL,
          total_round_trip_time_per_responses_received REAL,
          current_round_trip_time REAL,
          available_outgoing_bitrate REAL,
          requests_received BIGINT,
          requests_sent BIGINT,
          responses_received BIGINT,
          responses_sent BIGINT,
          consent_requests_sent BIGINT,
          packets_discarded_on_send BIGINT,
          bytes_discarded_on_send BIGINT,
          last_packet_received_timestamp TEXT,
          last_packet_sent_timestamp TEXT
        )
      `);
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS delay_measurements (
          id SERIAL PRIMARY KEY,
          run_id BIGINT NOT NULL REFERENCES runs(id),
          client_id BIGINT NOT NULL,
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          delay REAL NOT NULL
        )
      `);
      await this.pool.query(`
        CREATE INDEX IF NOT EXISTS idx_performance_metrics_run_id ON performance_metrics(run_id);
        CREATE INDEX IF NOT EXISTS idx_performance_metrics_timestamp ON performance_metrics(timestamp);
        CREATE INDEX IF NOT EXISTS idx_webrtc_data_metrics_run_id ON webrtc_data_metrics(run_id);
        CREATE INDEX IF NOT EXISTS idx_webrtc_data_metrics_timestamp ON webrtc_data_metrics(timestamp);
        CREATE INDEX IF NOT EXISTS idx_webrtc_audio_metrics_run_id ON webrtc_audio_metrics(run_id);
        CREATE INDEX IF NOT EXISTS idx_webrtc_audio_metrics_timestamp ON webrtc_audio_metrics(timestamp);
        CREATE INDEX IF NOT EXISTS idx_webrtc_video_metrics_run_id ON webrtc_video_metrics(run_id);
        CREATE INDEX IF NOT EXISTS idx_webrtc_video_metrics_timestamp ON webrtc_video_metrics(timestamp);
        CREATE INDEX IF NOT EXISTS idx_webrtc_candidate_pair_metrics_run_id ON webrtc_candidate_pair_metrics(run_id);
        CREATE INDEX IF NOT EXISTS idx_webrtc_candidate_pair_metrics_timestamp ON webrtc_candidate_pair_metrics(timestamp);
        CREATE INDEX IF NOT EXISTS idx_delay_measurements_run_id ON delay_measurements(run_id);
        CREATE INDEX IF NOT EXISTS idx_delay_measurements_timestamp ON delay_measurements(timestamp);
      `);
      logger.info("Database initialized successfully");
    } catch (error) {
      logger.error("Error initializing database:", error);
      throw error;
    }
  }
  async insertRun(args) {
    const result = await this.pool.query(
      `
        INSERT INTO runs (clients, width, height, duration, frame_rate, timestamp, audio, hardware, game_started_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id
      `,
      [
        args.clientCount,
        args.width,
        args.height,
        args.duration,
        args.frameRate,
        /* @__PURE__ */ new Date(),
        args.audio,
        args.hardware,
        /* @__PURE__ */ new Date()
      ]
    );
    return result.rows[0].id;
  }
  async updateGameStartedAt(runId2, gameStartedAt) {
    await this.pool.query(
      `
      UPDATE runs
      SET game_started_at = $1
      WHERE id = $2
      `,
      [gameStartedAt, runId2]
    );
    logger.info(`Updated game_started_at for run ${runId2}`);
  }
  async insertWebRTCMetrics(runId2, clientId, metrics) {
    const client = await this.pool.connect();
    try {
      await client.query("BEGIN");
      const dataQuery = `
        INSERT INTO webrtc_data_metrics (
          run_id, client_id, timestamp, label, protocol, data_channel_identifier, state,
          messages_sent, messages_sent_per_s, bytes_sent, bytes_sent_in_bits_per_s,
          messages_received, messages_received_per_s, bytes_received, bytes_received_in_bits_per_s
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
      `;
      for (const metric of metrics.dataChannelMetrics) {
        await client.query(dataQuery, [
          runId2,
          clientId,
          metric.timestamp,
          metric.label,
          metric.protocol,
          metric.dataChannelIdentifier,
          metric.state,
          metric.messagesSent,
          metric.messagesSent_per_s,
          metric.bytesSent,
          metric.bytesSent_in_bits_per_s,
          metric.messagesReceived,
          metric.messagesReceived_per_s,
          metric.bytesReceived,
          metric.bytesReceived_in_bits_per_s
        ]);
      }
      const audioQuery = `
        INSERT INTO webrtc_audio_metrics (
          run_id, client_id, timestamp, ssrc, kind, transport_id, codec_id, codec, jitter,
          packets_lost, playout_id, track_identifier, mid, remote_id, packets_received,
          packets_received_per_s, packets_discarded, packets_discarded_per_s,
          fec_packets_received, fec_packets_received_per_s, fec_packets_discarded,
          fec_packets_discarded_per_s, bytes_received, bytes_received_in_bits_per_s,
          header_bytes_received, header_bytes_received_in_bits_per_s,
          last_packet_received_timestamp, jitter_buffer_delay,
          jitter_buffer_delay_per_jitter_buffer_emitted_count_in_ms,
          jitter_buffer_target_delay,
          jitter_buffer_target_delay_per_jitter_buffer_emitted_count_in_ms,
          jitter_buffer_minimum_delay,
          jitter_buffer_minimum_delay_per_jitter_buffer_emitted_count_in_ms,
          jitter_buffer_emitted_count, total_samples_received,
          total_samples_received_per_s, concealed_samples, concealed_samples_per_s,
          concealed_samples_per_total_samples_received, silent_concealed_samples,
          silent_concealed_samples_per_s, concealment_events,
          inserted_samples_for_deceleration, inserted_samples_for_deceleration_per_s,
          removed_samples_for_acceleration, removed_samples_for_acceleration_per_s,
          audio_level, total_audio_energy, audio_level_in_rms,
          total_samples_duration, total_processing_delay,
          total_processing_delay_per_jitter_buffer_emitted_count_in_ms,
          jitter_buffer_flushes, delayed_packet_outage_samples,
          relative_packet_arrival_delay, interruption_count,
          total_interruption_duration
        ) VALUES (${Array.from({ length: 57 }, (_, i) => `$${i + 1}`).join(",")})
      `;
      for (const metric of metrics.audioMetrics) {
        await client.query(audioQuery, [
          runId2,
          clientId,
          metric.timestamp,
          metric.ssrc,
          metric.kind,
          metric.transportId,
          metric.codecId,
          metric.codec,
          metric.jitter,
          metric.packetsLost,
          metric.playoutId,
          metric.trackIdentifier,
          metric.mid,
          metric.remoteId,
          metric.packetsReceived,
          metric.packetsReceived_per_s,
          metric.packetsDiscarded,
          metric.packetsDiscarded_per_s,
          metric.fecPacketsReceived,
          metric.fecPacketsReceived_per_s,
          metric.fecPacketsDiscarded,
          metric.fecPacketsDiscarded_per_s,
          metric.bytesReceived,
          metric.bytesReceived_in_bits_per_s,
          metric.headerBytesReceived,
          metric.headerBytesReceived_in_bits_per_s,
          metric.lastPacketReceivedTimestamp,
          metric.jitterBufferDelay,
          metric.jitterBufferDelay_per_jitterBufferEmittedCount_in_ms,
          metric.jitterBufferTargetDelay,
          metric.jitterBufferTargetDelay_per_jitterBufferEmittedCount_in_ms,
          metric.jitterBufferMinimumDelay,
          metric.jitterBufferMinimumDelay_per_jitterBufferEmittedCount_in_ms,
          metric.jitterBufferEmittedCount,
          metric.totalSamplesReceived,
          metric.totalSamplesReceived_per_s,
          metric.concealedSamples,
          metric.concealedSamples_per_s,
          metric.concealedSamples_per_totalSamplesReceived,
          metric.silentConcealedSamples,
          metric.silentConcealedSamples_per_s,
          metric.concealmentEvents,
          metric.insertedSamplesForDeceleration,
          metric.insertedSamplesForDeceleration_per_s,
          metric.removedSamplesForAcceleration,
          metric.removedSamplesForAcceleration_per_s,
          metric.audioLevel,
          metric.totalAudioEnergy,
          metric.Audio_Level_in_RMS,
          metric.totalSamplesDuration,
          metric.totalProcessingDelay,
          metric.totalProcessingDelay_per_jitterBufferEmittedCount_in_ms,
          metric.jitterBufferFlushes,
          metric.delayedPacketOutageSamples,
          metric.relativePacketArrivalDelay,
          metric.interruptionCount,
          metric.totalInterruptionDuration
        ]);
      }
      const videoQuery = `
        INSERT INTO webrtc_video_metrics (
          run_id, client_id, timestamp, ssrc, kind, transport_id, codec_id, codec, jitter,
          packets_lost, track_identifier, mid, packets_received,
          packets_received_per_s, bytes_received, bytes_received_in_bits_per_s,
          header_bytes_received, header_bytes_received_in_bits_per_s,
          retransmitted_packets_received, retransmitted_packets_received_per_s,
          retransmitted_bytes_received, retransmitted_bytes_received_in_bits_per_s,
          rtx_ssrc, last_packet_received_timestamp, jitter_buffer_delay,
          jitter_buffer_delay_per_jitter_buffer_emitted_count_in_ms,
          jitter_buffer_target_delay,
          jitter_buffer_target_delay_per_jitter_buffer_emitted_count_in_ms,
          jitter_buffer_minimum_delay,
          jitter_buffer_minimum_delay_per_jitter_buffer_emitted_count_in_ms,
          jitter_buffer_emitted_count, frames_received, frames_received_per_s,
          frame_width, frame_height, frames_per_second, frames_decoded,
          frames_decoded_per_s, key_frames_decoded, key_frames_decoded_per_s,
          frames_dropped, total_decode_time,
          total_decode_time_per_frames_decoded_in_ms, total_processing_delay,
          total_processing_delay_per_jitter_buffer_emitted_count_in_ms,
          total_assembly_time,
          total_assembly_time_per_frames_assembled_from_multiple_packets_in_ms,
          frames_assembled_from_multiple_packets, total_inter_frame_delay,
          total_inter_frame_delay_per_frames_decoded_in_ms,
          total_squared_inter_frame_delay, inter_frame_delay_st_dev_in_ms,
          pause_count, total_pauses_duration, freeze_count, total_freezes_duration,
          decoder_implementation, fir_count, pli_count, nack_count,
          goog_timing_frame_info, power_efficient_decoder, min_playout_delay
        ) VALUES (${Array.from({ length: 63 }, (_, i) => `$${i + 1}`).join(",")})
      `;
      for (const metric of metrics.videoMetrics) {
        await client.query(videoQuery, [
          runId2,
          clientId,
          metric.timestamp,
          metric.ssrc,
          metric.kind,
          metric.transportId,
          metric.codecId,
          metric.codec,
          metric.jitter,
          metric.packetsLost,
          metric.trackIdentifier,
          metric.mid,
          metric.packetsReceived,
          metric.packetsReceived_per_s,
          metric.bytesReceived,
          metric.bytesReceived_in_bits_per_s,
          metric.headerBytesReceived,
          metric.headerBytesReceived_in_bits_per_s,
          metric.retransmittedPacketsReceived,
          metric.retransmittedPacketsReceived_per_s,
          metric.retransmittedBytesReceived,
          metric.retransmittedBytesReceived_in_bits_per_s,
          metric.rtxSsrc,
          metric.lastPacketReceivedTimestamp,
          metric.jitterBufferDelay,
          metric.jitterBufferDelay_per_jitterBufferEmittedCount_in_ms,
          metric.jitterBufferTargetDelay,
          metric.jitterBufferTargetDelay_per_jitterBufferEmittedCount_in_ms,
          metric.jitterBufferMinimumDelay,
          metric.jitterBufferMinimumDelay_per_jitterBufferEmittedCount_in_ms,
          metric.jitterBufferEmittedCount,
          metric.framesReceived,
          metric.framesReceived_per_s,
          metric.frameWidth,
          metric.frameHeight,
          metric.framesPerSecond,
          metric.framesDecoded,
          metric.framesDecoded_per_s,
          metric.keyFramesDecoded,
          metric.keyFramesDecoded_per_s,
          metric.framesDropped,
          metric.totalDecodeTime,
          metric.totalDecodeTime_per_framesDecoded_in_ms,
          metric.totalProcessingDelay,
          metric.totalProcessingDelay_per_jitterBufferEmittedCount_in_ms,
          metric.totalAssemblyTime,
          metric.totalAssemblyTime_per_framesAssembledFromMultiplePackets_in_ms,
          metric.framesAssembledFromMultiplePackets,
          metric.totalInterFrameDelay,
          metric.totalInterFrameDelay_per_framesDecoded_in_ms,
          metric.totalSquaredInterFrameDelay,
          metric.interFrameDelayStDev_in_ms,
          metric.pauseCount,
          metric.totalPausesDuration,
          metric.freezeCount,
          metric.totalFreezesDuration,
          metric.decoderImplementation,
          metric.firCount,
          metric.pliCount,
          metric.nackCount,
          metric.googTimingFrameInfo,
          metric.powerEfficientDecoder,
          metric.minPlayoutDelay
        ]);
      }
      const candidatePairQuery = `
        INSERT INTO webrtc_candidate_pair_metrics (
          run_id, client_id, timestamp, transport_id, local_candidate_id, remote_candidate_id,
          state, priority, nominated, writable, packets_sent, packets_sent_per_s,
          bytes_sent, bytes_sent_in_bits_per_s, packets_received, packets_received_per_s,
          bytes_received, bytes_received_in_bits_per_s, total_round_trip_time,
          total_round_trip_time_per_responses_received, current_round_trip_time,
          available_outgoing_bitrate, requests_received, requests_sent,
          responses_received, responses_sent, consent_requests_sent,
          packets_discarded_on_send, bytes_discarded_on_send,
          last_packet_received_timestamp, last_packet_sent_timestamp
        ) VALUES (${Array.from({ length: 31 }, (_, i) => `$${i + 1}`).join(",")})
      `;
      for (const metric of metrics.candidatePairMetrics) {
        await client.query(candidatePairQuery, [
          runId2,
          clientId,
          metric.timestamp,
          metric.transportId,
          metric.localCandidateId,
          metric.remoteCandidateId,
          metric.state,
          metric.priority,
          metric.nominated,
          metric.writable,
          metric.packetsSent,
          metric.packetsSent_per_s,
          metric.bytesSent,
          metric.bytesSent_in_bits_per_s,
          metric.packetsReceived,
          metric.packetsReceived_per_s,
          metric.bytesReceived,
          metric.bytesReceived_in_bits_per_s,
          metric.totalRoundTripTime,
          metric.totalRoundTripTime_per_responsesReceived,
          metric.currentRoundTripTime,
          metric.availableOutgoingBitrate,
          metric.requestsReceived,
          metric.requestsSent,
          metric.responsesReceived,
          metric.responsesSent,
          metric.consentRequestsSent,
          metric.packetsDiscardedOnSend,
          metric.bytesDiscardedOnSend,
          metric.lastPacketReceivedTimestamp,
          metric.lastPacketSentTimestamp
        ]);
      }
      await client.query("COMMIT");
    } catch (error) {
      await client.query("ROLLBACK");
      logger.error("Error inserting WebRTC metrics:", error);
      throw error;
    } finally {
      client.release();
    }
  }
  async insertMetrics(runId2, metrics) {
    try {
      await this.pool.query(
        `
          INSERT INTO performance_metrics (
            run_id,
            timestamp,
            gpu_utilization,
            working_set_private,
            cpu_usage,
            bytes_received,
            bytes_sent,
            packets_received,
            packets_sent,
            nv_gpu_power,
            nv_gpu_temp,
            nv_gpu_mem_temp,
            nv_gpu_sm,
            nv_gpu_mem,
            nv_gpu_enc,
            nv_gpu_dec,
            nv_gpu_jpg,
            nv_gpu_ofa,
            nv_gpu_mem_clock,
            nv_gpu_clock
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
        `,
        [
          runId2,
          metrics.timestamp,
          metrics.gpuUtilization,
          metrics.workingSetPrivate,
          metrics.cpuUsage,
          metrics.bytesReceived,
          metrics.bytesSent,
          metrics.packetsReceived,
          metrics.packetsSent,
          metrics.nvGpuPower,
          metrics.nvGpuTemp,
          metrics.nvGpuMemTemp,
          metrics.nvGpuSm,
          metrics.nvGpuMem,
          metrics.nvGpuEnc,
          metrics.nvGpuDec,
          metrics.nvGpuJpg,
          metrics.nvGpuOfa,
          metrics.nvGpuMemClock,
          metrics.nvGpuClock
        ]
      );
    } catch (error) {
      logger.error("Error inserting performance metrics:", error);
      throw error;
    }
  }
  async close() {
    await this.pool.end();
  }
  async deleteRun(runId2) {
    try {
      await this.pool.query(
        `
        DELETE FROM performance_metrics WHERE run_id = $1
      `,
        [runId2]
      );
      await this.pool.query(
        `
        DELETE FROM webrtc_data_metrics WHERE run_id = $1
      `,
        [runId2]
      );
      await this.pool.query(
        `
        DELETE FROM webrtc_audio_metrics WHERE run_id = $1
      `,
        [runId2]
      );
      await this.pool.query(
        `
        DELETE FROM webrtc_video_metrics WHERE run_id = $1
      `,
        [runId2]
      );
      await this.pool.query(
        `
        DELETE FROM webrtc_candidate_pair_metrics WHERE run_id = $1
      `,
        [runId2]
      );
      await this.pool.query(
        `
        DELETE FROM delay_measurements WHERE run_id = $1
      `,
        [runId2]
      );
      await this.pool.query(
        `
        DELETE FROM runs WHERE id = $1
      `,
        [runId2]
      );
    } catch (error) {
      throw new Error(`Failed to delete run ${runId2}: ${error}`);
    }
  }
  async insertDelayValues(runId2, clientId, delayValues) {
    const client = await this.pool.connect();
    try {
      await client.query("BEGIN");
      const query = `
        INSERT INTO delay_measurements (
          run_id, client_id, timestamp, delay
        ) VALUES ($1, $2, $3, $4)
      `;
      for (const measurement of delayValues) {
        const timestamp = new Date(measurement.timestamp);
        await client.query(query, [
          runId2,
          clientId,
          timestamp,
          measurement.delay
        ]);
      }
      await client.query("COMMIT");
      logger.info(
        `Inserted ${delayValues.length} delay measurements for run ${runId2}, client ${clientId}`
      );
    } catch (error) {
      await client.query("ROLLBACK");
      logger.error("Error inserting delay measurements:", error);
      throw error;
    } finally {
      client.release();
    }
  }
};

// src/unityCommander.ts
var import_node_child_process3 = require("child_process");
var import_node_events3 = require("events");
var import_ws = require("ws");

// src/gamePerformanceMonitor.ts
var import_node_child_process2 = require("child_process");
var import_node_events2 = require("events");
var GamePerformanceMonitor = class extends import_node_events2.EventEmitter {
  typeperfProcess = null;
  nvidiaSmiProcess = null;
  processId;
  processName;
  dataBuffer = "";
  nvidiaSmiBuffer = "";
  nvMetrics = {};
  headerParsed = false;
  constructor(processId, processName = "GameBeamTechDemo") {
    super();
    this.processId = processId;
    this.processName = processName;
  }
  start() {
    this.startTypeperf();
    this.startNvidiaSmi();
    logger.info("Performance monitoring started");
  }
  startTypeperf() {
    const counters = [
      `"\\GPU Engine(pid_${this.processId}*3D)\\Utilization Percentage"`,
      `"\\Process(${this.processName})\\Working Set - Private"`,
      `"\\Process(${this.processName})\\% Processor Time"`,
      `"\\Network Interface(Real*)\\Bytes Received/sec"`,
      `"\\Network Interface(Real*)\\Bytes Sent/sec"`,
      `"\\Network Interface(Real*)\\Packets Received/sec"`,
      `"\\Network Interface(Real*)\\Packets Sent/sec"`
    ];
    const typeperfArgs = [...counters, "-si", "1"];
    this.typeperfProcess = (0, import_node_child_process2.spawn)("typeperf", typeperfArgs, { shell: true });
    if (!this.typeperfProcess.stdout || !this.typeperfProcess.stderr) {
      throw new Error("Failed to create typeperf process streams");
    }
    this.typeperfProcess.stdout.on("data", (data) => {
      this.dataBuffer += data.toString();
      const lines = this.dataBuffer.split("\r\n");
      if (lines.length === 0)
        return;
      if (!lines[lines.length - 1]?.endsWith("\r\n")) {
        this.dataBuffer = lines.pop() || "";
      } else {
        this.dataBuffer = "";
      }
      for (let i = 0; i < lines.length; i++) {
        const trimmedLine = lines[i].trim();
        if (trimmedLine && !trimmedLine.startsWith('"(PDH-CSV')) {
          try {
            const values = trimmedLine.split(",").map((s) => s.replace(/"/g, "").trim());
            if (values.length < 8) {
              logger.error("Invalid performance data format:", trimmedLine);
              continue;
            }
            const [
              timestamp,
              gpuStr,
              memoryStr,
              cpuStr,
              bytesReceivedStr,
              bytesSentStr,
              packetsReceivedStr,
              packetsSentStr
            ] = values;
            if (!timestamp || !gpuStr || !memoryStr || !cpuStr || !bytesReceivedStr || !bytesSentStr || !packetsReceivedStr || !packetsSentStr) {
              logger.error("Missing performance data values:", trimmedLine);
              continue;
            }
            const metrics = {
              timestamp: new Date(timestamp),
              gpuUtilization: Number.parseFloat(gpuStr) || 0,
              workingSetPrivate: Number.parseFloat(memoryStr) || 0,
              cpuUsage: Number.parseFloat(cpuStr) || 0,
              bytesReceived: Number.parseFloat(bytesReceivedStr) || 0,
              bytesSent: Number.parseFloat(bytesSentStr) || 0,
              packetsReceived: Number.parseFloat(packetsReceivedStr) || 0,
              packetsSent: Number.parseFloat(packetsSentStr) || 0,
              nvGpuPower: this.nvMetrics.nvGpuPower || 0,
              nvGpuTemp: this.nvMetrics.nvGpuTemp || 0,
              nvGpuMemTemp: this.nvMetrics.nvGpuMemTemp || 0,
              nvGpuSm: this.nvMetrics.nvGpuSm || 0,
              nvGpuMem: this.nvMetrics.nvGpuMem || 0,
              nvGpuEnc: this.nvMetrics.nvGpuEnc || 0,
              nvGpuDec: this.nvMetrics.nvGpuDec || 0,
              nvGpuJpg: this.nvMetrics.nvGpuJpg || 0,
              nvGpuOfa: this.nvMetrics.nvGpuOfa || 0,
              nvGpuMemClock: this.nvMetrics.nvGpuMemClock || 0,
              nvGpuClock: this.nvMetrics.nvGpuClock || 0
            };
            this.emit("metrics", metrics);
            logger.debug("Performance metrics:", metrics);
          } catch (error) {
            logger.error("Error parsing performance metrics:", error);
          }
        }
      }
    });
    this.typeperfProcess.stderr.on("data", (data) => {
      logger.error("Typeperf error:", data.toString());
    });
    this.typeperfProcess.on("error", (error) => {
      logger.error("Failed to start typeperf:", error);
      this.emit("error", error);
    });
    this.typeperfProcess.on("exit", (code) => {
      logger.info(`Typeperf process exited with code ${code}`);
      this.typeperfProcess = null;
      this.emit("stopped");
    });
  }
  startNvidiaSmi() {
    this.nvidiaSmiProcess = (0, import_node_child_process2.spawn)("nvidia-smi.exe", ["dmon"], { shell: true });
    if (!this.nvidiaSmiProcess.stdout || !this.nvidiaSmiProcess.stderr) {
      logger.error("Failed to create nvidia-smi process streams");
      return;
    }
    this.nvidiaSmiProcess.stdout.on("data", (data) => {
      this.nvidiaSmiBuffer += data.toString();
      const lines = this.nvidiaSmiBuffer.split("\n");
      if (lines.length === 0)
        return;
      if (!lines[lines.length - 1]?.endsWith("\n")) {
        this.nvidiaSmiBuffer = lines.pop() || "";
      } else {
        this.nvidiaSmiBuffer = "";
      }
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line || line.startsWith("#")) {
          if (line.startsWith("# gpu")) {
            this.headerParsed = true;
          }
          continue;
        }
        if (this.headerParsed) {
          try {
            const values = line.split(/\s+/).filter(Boolean);
            if (values.length < 12) {
              continue;
            }
            const [
              _gpuIdx,
              power,
              gpuTemp,
              memTemp,
              sm,
              mem,
              enc,
              dec,
              jpg,
              ofa,
              memClock,
              gpuClock
            ] = values;
            this.nvMetrics = {
              nvGpuPower: Number.parseFloat(power || "0"),
              nvGpuTemp: Number.parseFloat(gpuTemp || "0"),
              nvGpuMemTemp: memTemp === "-" ? 0 : Number.parseFloat(memTemp || "0"),
              nvGpuSm: Number.parseFloat(sm || "0"),
              nvGpuMem: Number.parseFloat(mem || "0"),
              nvGpuEnc: Number.parseFloat(enc || "0"),
              nvGpuDec: Number.parseFloat(dec || "0"),
              nvGpuJpg: Number.parseFloat(jpg || "0"),
              nvGpuOfa: Number.parseFloat(ofa || "0"),
              nvGpuMemClock: Number.parseFloat(memClock || "0"),
              nvGpuClock: Number.parseFloat(gpuClock || "0")
            };
            logger.debug("NVIDIA GPU metrics updated:", this.nvMetrics);
          } catch (error) {
            logger.error("Error parsing NVIDIA metrics:", error);
          }
        }
      }
    });
    this.nvidiaSmiProcess.stderr.on("data", (data) => {
      logger.error("NVIDIA SMI error:", data.toString());
    });
    this.nvidiaSmiProcess.on("error", (error) => {
      logger.error("Failed to start NVIDIA SMI:", error);
    });
    this.nvidiaSmiProcess.on("exit", (code) => {
      logger.info(`NVIDIA SMI process exited with code ${code}`);
      this.nvidiaSmiProcess = null;
    });
  }
  stop() {
    if (this.typeperfProcess) {
      this.typeperfProcess.kill();
      (0, import_node_child_process2.exec)("taskkill /f /im typeperf.exe", (error) => {
        if (error) {
          logger.error("Error killing typeperf process:", error);
        } else {
          logger.info("Typeperf process killed successfully");
        }
      });
      this.typeperfProcess = null;
    }
    if (this.nvidiaSmiProcess) {
      this.nvidiaSmiProcess.kill();
      (0, import_node_child_process2.exec)("taskkill /f /im nvidia-smi.exe", (error) => {
        if (error) {
          logger.error("Error killing nvidia-smi process:", error);
        } else {
          logger.info("NVIDIA SMI process killed successfully");
        }
      });
      this.nvidiaSmiProcess = null;
    }
    logger.info("Performance monitoring stopped");
  }
};

// src/unityCommander.ts
var UnityCommander = class extends import_node_events3.EventEmitter {
  wss;
  client = null;
  port;
  runId;
  width;
  height;
  frameRate;
  audio;
  hardware;
  link;
  gameProcess = null;
  performanceMonitor = null;
  constructor(runId2, width = 1920, height = 1080, frameRate = 30, audio = true, hardware = false, port = 8e3) {
    super();
    this.runId = runId2;
    this.width = width;
    this.frameRate = frameRate;
    this.height = height;
    this.port = port;
    this.link = "";
    this.audio = audio;
    this.hardware = hardware;
  }
  async start() {
    const execPath = process.env.UNITY_GAME_PATH;
    if (!execPath) {
      throw new Error("UNITY_GAME_PATH environment variable is not set");
    }
    try {
      this.gameProcess = (0, import_node_child_process3.spawn)(
        execPath,
        [
          "--width",
          this.width.toString(),
          "--height",
          this.height.toString(),
          "--frame-rate",
          this.frameRate.toString(),
          "--hw-encoder",
          this.hardware ? "true" : "false",
          this.audio ? "" : "--no-audio"
        ],
        {
          stdio: "ignore"
        }
      );
      if (!this.gameProcess.pid) {
        throw new Error("Failed to get process ID for the game");
      }
      this.performanceMonitor = new GamePerformanceMonitor(
        this.gameProcess.pid
      );
      this.performanceMonitor.on("metrics", (metrics) => {
        this.emit("metrics", metrics);
      });
      this.performanceMonitor.start();
      this.gameProcess.on("error", (error) => {
        logger.error("Failed to start Unity game:", error);
        throw error;
      });
      this.gameProcess.on("exit", (code) => {
        logger.info(`Unity game process exited with code ${code}`);
        this.gameProcess = null;
      });
      logger.info("Unity game process started");
    } catch (error) {
      logger.error("Error starting Unity game:", error);
      throw error;
    }
    logger.info(`WebSocket server is listening on port ${this.port}`);
    this.wss = new import_ws.WebSocketServer({ port: this.port });
    this.wss.on("listening", () => {
      this.emit(
        "started",
        `WebSocket server is listening on port ${this.port}`
      );
    });
    this.wss.on("connection", (ws) => {
      this.handleNewConnection(ws);
    });
    this.wss.on("error", (error) => {
      this.emit("error", error);
    });
  }
  async startGame() {
    if (!this.client) {
      throw new Error("No client connected");
    }
    this.client.send(
      JSON.stringify({
        command: "start"
      })
    );
  }
  handleNewConnection(ws) {
    this.client = ws;
    this.emit("connection", ws);
    ws.on("message", (data) => {
      const message = JSON.parse(data.toString());
      logger.info(`Received message: ${message.type}`);
      switch (message.type) {
        case "ready":
          this.link = message.link;
          break;
      }
      this.emit("message", message);
    });
    ws.on("close", () => {
      this.client = null;
      this.emit("disconnection", ws);
    });
    ws.on("error", (error) => {
      this.emit("error", error);
    });
  }
  async stop() {
    if (this.performanceMonitor) {
      this.performanceMonitor.stop();
      this.performanceMonitor = null;
    }
    if (this.gameProcess) {
      this.gameProcess.kill();
      this.gameProcess = null;
      logger.info("Unity game process stopped");
    }
    this.client = null;
    this.wss?.close();
  }
};

// src/commands/start.ts
var import_config = require("dotenv/config");
var command2 = "start";
var describe2 = "start a new analysis run.";
var aliases2 = ["s"];
function builder2(yargs2) {
  return yargs2.option("clients", {
    type: "number",
    alias: "c",
    default: 1
  }).option("width", {
    type: "number",
    alias: "w",
    default: 1920
  }).option("height", {
    type: "number",
    alias: "h",
    default: 1080
  }).option("audio", {
    type: "boolean",
    alias: "a",
    default: true
  }).option("frameRate", {
    type: "number",
    alias: "f",
    default: 30
  }).option("duration", {
    type: "number",
    alias: "d",
    description: "Duration of the run in seconds",
    default: 60
  }).option("hardware", {
    type: "boolean",
    alias: "hw",
    description: "Use hardware acceleration",
    default: true
  });
}
var unityCommander;
var clients = [];
var clientsConnected = 0;
var connectionTimeoutId = null;
var databaseManager = new DatabaseManager({
  host: process.env.DB_HOST || "localhost",
  port: Number.parseInt(process.env.DB_PORT || "5432"),
  database: process.env.DB_NAME || "gamebeam",
  user: process.env.DB_USER || "postgres",
  password: process.env.DB_PASSWORD || "postgres"
});
var clientCount = 0;
var runId = 0;
var duration = 0;
async function cleanup(deleteRunFromDb = false) {
  logger.info("Stopping analysis run...");
  if (connectionTimeoutId) {
    clearTimeout(connectionTimeoutId);
    connectionTimeoutId = null;
  }
  for (const client of clients) {
    await client.stop();
  }
  clients = [];
  if (unityCommander) {
    await unityCommander.stop();
  }
  await new Promise((resolve) => setTimeout(resolve, 1e3));
  if (deleteRunFromDb) {
    try {
      await databaseManager.deleteRun(runId);
      logger.info(
        `Run ${runId} deleted from database due to connection timeout.`
      );
    } catch (error) {
      logger.error("Error deleting run from database:", error);
    }
  }
  databaseManager.close();
}
async function handler2(argv) {
  clientCount = argv.clients;
  duration = argv.duration;
  const width = argv.width;
  const height = argv.height;
  const frameRate = argv.frameRate;
  const audio = argv.audio;
  const hardware = argv.hardware;
  await databaseManager.initialize();
  runId = await databaseManager.insertRun({
    clientCount,
    width,
    height,
    duration,
    frameRate,
    audio,
    hardware
  });
  unityCommander = new UnityCommander(
    runId,
    width,
    height,
    frameRate,
    audio,
    hardware
  );
  unityCommander.on("connection", (_ws) => {
    logger.info("New host connected.");
  });
  unityCommander.on("disconnection", (_ws) => {
    logger.info("host disconnected.");
  });
  unityCommander.on("message", async (message) => {
    switch (message.type) {
      case "ready":
        await startClients();
        break;
    }
  });
  unityCommander.on("metrics", async (metrics) => {
    logger.debug("Performance metrics:", metrics);
    await databaseManager.insertMetrics(runId, metrics);
  });
  unityCommander.start();
}
function createClientWithIndex(index, link) {
  return new Promise((resolve, reject) => {
    const clientCommander = new ClientCommander(link);
    clients.push(clientCommander);
    const clientIndex = index + 1;
    clientCommander.on("gameReady", async () => {
      logger.info(`Client number ${clientIndex} ready.`);
      clientsConnected++;
      if (clientsConnected === clientCount && connectionTimeoutId) {
        logger.info("All clients connected successfully.");
        clearTimeout(connectionTimeoutId);
        connectionTimeoutId = null;
      }
      resolve();
    });
    clientCommander.on("metrics", async (metrics) => {
      await databaseManager.insertWebRTCMetrics(runId, clientIndex, metrics);
    });
    clientCommander.on(
      "delayValues",
      async (delayValues) => {
        await databaseManager.insertDelayValues(
          runId,
          clientIndex,
          delayValues
        );
      }
    );
    clientCommander.on("error", (error) => {
      reject(error);
    });
    logger.info(`Starting client number ${clientIndex}.`);
    clientCommander.start().catch((error) => {
      logger.error(`Error starting client ${clientIndex}:`, error);
      reject(error);
    });
  });
}
async function startClients() {
  logger.info(`Starting ${clientCount} clients...`);
  const promises = [];
  clientsConnected = 0;
  connectionTimeoutId = setTimeout(() => {
    if (clientsConnected < clientCount) {
      logger.error(
        `Connection timeout: Only ${clientsConnected} of ${clientCount} clients connected after 20 seconds.`
      );
      cleanup(true).then(() => {
        process.exit(1);
      }).catch((err) => {
        logger.error("Error during cleanup:", err);
        process.exit(1);
      });
    }
  }, 12e4);
  for (let i = 0; i < clientCount; i++) {
    promises.push(createClientWithIndex(i, unityCommander.link));
  }
  try {
    await Promise.all(promises);
    logger.info("Game and Timer started.");
    await databaseManager.updateGameStartedAt(runId, /* @__PURE__ */ new Date());
    setTimeout(() => {
      cleanup().then(() => {
        process.exit(0);
      }).catch((err) => {
        logger.error("Error during cleanup:", err);
        process.exit(1);
      });
    }, duration * 1e3);
    await unityCommander.startGame();
    for (const client of clients) {
      client.startGame();
    }
  } catch (error) {
    logger.error("Failed to start all clients:", error);
    await cleanup(true);
    process.exit(1);
  }
}

// src/commands/index.ts
var commands = [start_exports, batch_exports];

// bin/run.ts
(0, import_dotenv.config)();
var run = (0, import_yargs.default)(process.argv.slice(2));
for (const command3 of commands) {
  run.command(command3);
}
run.demandCommand(1, "You need at least one command before moving on").help().argv;
